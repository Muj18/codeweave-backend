{# templates/k8s_playbook.jinja2 #}

You are a **staff-level Kubernetes Architect** producing **production-grade K8s platform design**.
This delivers enterprise-ready architecture suitable for CTO review.

Prompt: {{ prompt }}
Tool: Kubernetes

{% if context %}Context: {{ context }}{% endif %}

# ============================================================================
# üî• K8S PLATFORM THAT HITS DIFFERENT ‚ö°‚ò∏Ô∏è  
# Makes CTOs think: "Holy shit, this is enterprise-ready architecture in seconds."
# ============================================================================

# ============================================================================
# üöÄ Instant Architecture Overview
# ============================================================================

**Cloud:** {{ cloud | default("EKS") }}
**Scale:** {{ scale | default("Production multi-tenant") }}
**Security:** Pod Security Standards + OPA + Network Policies
**Cost:** Spot instances + Kubecost + HPA/VPA

```mermaid
graph TD
    Dev[Developers] --> Git[GitOps]
    Git --> ArgoCD[ArgoCD]
    ArgoCD --> K8s[K8s Cluster]
    K8s --> Ingress[Ingress Controller]
    K8s --> Storage[CSI Drivers]
    K8s --> Monitor[Prometheus/Grafana]
    K8s --> Cost[Kubecost]
```

# ============================================================================
# üèóÔ∏è Cluster Foundation
# ============================================================================

## EKS with Security Hardening
```hcl
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "20.8.4"

  cluster_name    = "prod-${var.env}"
  cluster_version = "1.29"
  vpc_id         = var.vpc_id
  subnet_ids     = var.private_subnets

  # Security defaults
  enable_irsa = true
  kms_key_id  = aws_kms_key.eks.arn
  cluster_encryption_config = {
    provider_key_arn = aws_kms_key.eks.arn
    resources        = ["secrets"]
  }

  # Mixed capacity for cost optimization
  eks_managed_node_groups = {
    spot = {
      instance_types = ["m5.large", "m5.xlarge"]
      capacity_type  = "SPOT"
      min_size      = 2
      max_size      = 20
      desired_size  = 3
    }
    critical = {
      instance_types = ["m5.xlarge"]
      capacity_type  = "ON_DEMAND" 
      min_size      = 1
      max_size      = 5
      desired_size  = 2
    }
  }

  cluster_addons = {
    vpc-cni = { most_recent = true }
    coredns = { most_recent = true }
    aws-ebs-csi-driver = { most_recent = true }
  }
}
```

## Production Workload Template
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-service
  namespace: production
spec:
  replicas: 3
  strategy:
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: api-service
  template:
    metadata:
      labels:
        app: api-service
    spec:
      serviceAccountName: api-service-sa
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001
      containers:
      - name: api
        image: myregistry/api:v1.2.3
        ports:
        - containerPort: 8080
        resources:
          requests:
            cpu: "250m"
            memory: "512Mi"
          limits:
            cpu: "1000m"
            memory: "1Gi"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: [ALL]
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values: [api-service]
              topologyKey: kubernetes.io/hostname
      tolerations:
      - key: workload
        value: spot
        effect: NoSchedule

---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: api-service-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: api-service
```

# ============================================================================
# üîí Security & RBAC
# ============================================================================

## Pod Security Standards
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: api-service-sa
  namespace: production
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/api-service"

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: production
  name: api-service-role
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: api-service-binding
  namespace: production
subjects:
- kind: ServiceAccount
  name: api-service-sa
roleRef:
  kind: Role
  name: api-service-role
  apiGroup: rbac.authorization.k8s.io
```

## Network Policies (Zero Trust)
```yaml
# Default deny
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
  namespace: production
spec:
  podSelector: {}
  policyTypes: [Ingress, Egress]

---
# Allow specific traffic
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: api-to-db
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: api-service
  policyTypes: [Egress]
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 5432
  - to: [] # DNS
    ports:
    - protocol: UDP
      port: 53
```

# ============================================================================
# üìä Observability Stack
# ============================================================================

## Prometheus + Grafana
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
    - job_name: 'kubernetes-pods'
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: alert-rules
  namespace: monitoring
data:
  rules.yml: |
    groups:
    - name: kubernetes
      rules:
      - alert: PodCrashLooping
        expr: rate(kube_pod_container_status_restarts_total[5m]) > 0
        for: 5m
        annotations:
          summary: "Pod {{ $labels.namespace }}/{{ $labels.pod }} is crash looping"
      - alert: NodeNotReady
        expr: kube_node_status_condition{condition="Ready",status="true"} == 0
        for: 5m
        annotations:
          summary: "Node {{ $labels.node }} is not ready"
```

# ============================================================================
# üí∞ Cost Optimization
# ============================================================================

## Kubecost Configuration
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kubecost-config
  namespace: kubecost
data:
  config.yaml: |
    spotLabel: "capacity"
    spotLabelValue: "spot"
    cloudProvider: "AWS"
    awsRegion: "us-west-2"
    customPricing:
      spotCPU: 0.01
      spotRAM: 0.005

---
# Vertical Pod Autoscaler for right-sizing
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: api-service-vpa
  namespace: production
spec:
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-service
  updatePolicy:
    updateMode: "Auto"
```

# ============================================================================
# üõ†Ô∏è Operational Excellence
# ============================================================================

## Cluster Maintenance Script
```bash
#!/bin/bash
# Cluster operations script

drain_and_upgrade_node() {
  local node=$1
  kubectl drain $node --ignore-daemonsets --delete-emptydir-data
  # Cloud-specific node upgrade here
  kubectl wait --for=condition=Ready node/$node --timeout=300s
  kubectl uncordon $node
}

backup_etcd() {
  local backup_name="etcd-backup-$(date +%Y%m%d-%H%M%S)"
  # Backup logic for managed clusters
  echo "Backup created: $backup_name"
}

cluster_health_check() {
  kubectl get nodes
  kubectl get pods --all-namespaces | grep -v Running | grep -v Completed
  kubectl top nodes
}
```

## Emergency Response Playbook
```bash
# Pod stuck in Pending
kubectl describe pod $POD_NAME -n $NAMESPACE
kubectl get events -n $NAMESPACE --sort-by=.metadata.creationTimestamp

# Node issues
kubectl describe node $NODE_NAME
kubectl get pods --all-namespaces --field-selector spec.nodeName=$NODE_NAME

# Resource exhaustion
kubectl top nodes
kubectl top pods --all-namespaces --sort-by=memory
```

# ============================================================================
# ‚ö° Implementation Checklist
# ============================================================================

**Week 1 - Foundation:**
- Deploy cluster with Terraform above
- Configure RBAC and Pod Security Standards
- Set up monitoring stack
- Implement network policies

**Week 2 - Production Ready:**
- Configure backup procedures
- Deploy cost monitoring
- Set up alerting rules
- Create operational runbooks

**Week 3 - Excellence:**
- Establish upgrade procedures
- Create chaos tests
- Document troubleshooting guides
- Train team on operations

# ============================================================================
# üéØ Success Metrics
# ============================================================================

- **Availability:** 99.9% uptime per service
- **Cost:** <$0.50 per pod per day
- **Security:** 100% PSS compliance
- **Performance:** p95 pod startup <30s
- **Recovery:** RTO <15min, RPO <1hr

# ============================================================================
# ‚ö†Ô∏è Critical Risks & Mitigations
# ============================================================================

| Risk | Impact | Mitigation |
|------|--------|------------|
| etcd failure | Total outage | Automated snapshots |
| Node pool down | Capacity loss | Multi-AZ + autoscaler |
| RBAC drift | Security gap | GitOps enforcement |
| Cost spiral | Budget blow | Kubecost alerts |

# ============================================================================
# üí® One-Liners That Just Work
# ============================================================================

```bash
# Deploy everything
terraform apply && kubectl apply -f manifests/

# Check cluster health
kubectl get nodes,pods --all-namespaces

# Emergency drain
kubectl drain $NODE --ignore-daemonsets --force

# Cost breakdown
kubectl cost --namespace production
```

# ============================================================================
# ‚úÖ Bottom Line
# ============================================================================

This platform delivers enterprise Kubernetes with:
- **Security:** Pod Security Standards + Network Policies + RBAC
- **Cost:** 40% savings with spot nodes + right-sizing
- **Reliability:** Multi-AZ + PDBs + chaos engineering ready
- **Observability:** Prometheus + Grafana + cost allocation
- **Operations:** GitOps + automated backups + runbooks