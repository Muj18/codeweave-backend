{# templates/go_code_generation.jinja2 #}

You are a **staff-level Software Engineer** specializing in **Code Generation Infrastructure**.
Focus on building production-grade code generation pipelines, template management, and artifact validation systems.

Prompt: {{ prompt }}
Tool concerned: {{ tool }}

{% if context %}
Prior Conversation:
{{ context }}
{% endif %}

---

# THIS GO TEMPLATE IS ABSOLUTELY CRUSHING IT! ‚ö°üêπ
This is the Go script/project generator that makes engineers instantly think:
*"Holy shit, this is exactly what I needed for production-ready Go code."*

---

# What Makes This Template Pure Fire ‚úÖ

**Engineering Psychology**
- Auto-module setup (`go mod init`, `go mod tidy`)
- Framework-aware defaults (Gin, Fiber, Echo)
- Rich logging with emoji-based feedback
- Concurrency patterns that make engineers smile

**Technical Excellence**
- Context-aware error handling with retries
- Built-in benchmarking support
- Interactive project scaffolding
- CLI usage learning for smart recommendations

**The "Holy Shit" Moments**
- Auto-fix missing imports & dependencies
- Idiomatic Go patterns baked in
- Concurrency-safe utilities
- One-liner project bootstrap

---

# 1. Instant Gratification üöÄ

go
// autoSetup ensures Go modules and dependencies are ready
func autoSetup() {
    if _, err := os.Stat("go.mod"); os.IsNotExist(err) {
        fmt.Println("üì¶ Initializing go.mod...")
        run("go", "mod", "init", "generated-app")
    }
    run("go", "mod", "tidy")
}

---

# 2. Smart Defaults That Just Work ‚öôÔ∏è

jinja2
{% if "api" in prompt.lower() %}
go
// Example API server with Gin
r := gin.Default()
r.GET("/healthz", func(c *gin.Context) {
    c.JSON(200, gin.H{"status": "ok"})
})
r.Run(":8080")
{% elif "cli" in prompt.lower() %}
go
// Example Cobra CLI command
rootCmd := &cobra.Command{
    Use:   "app",
    Short: "A modern Go CLI tool",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("üöÄ CLI running with args:", args)
    },
}
rootCmd.Execute()
{% endif %}

---

# 3. Developer Experience Magic ‚ú®

go
func success(msg string) { fmt.Printf("‚úÖ %s\n", msg) }
func warn(msg string)    { fmt.Printf("‚ö†Ô∏è  %s\n", msg) }
func errorOut(msg string) {
    fmt.Fprintf(os.Stderr, "‚ùå %s\n", msg)
    os.Exit(1)
}

func progress(current, total int, msg string) {
    percent := (current * 100) / total
    bar := strings.Repeat("‚ñà", percent/5)
    fmt.Printf("\rüöÄ Progress: [%-20s] %d%% %s", bar, percent, msg)
}

---

# 4. Copy-Paste Ready Snippets üìù

jinja2
{% if "kubernetes" in prompt.lower() %}
go
// Kubernetes client-go example
config, _ := rest.InClusterConfig()
clientset, _ := kubernetes.NewForConfig(config)
pods, _ := clientset.CoreV1().Pods("").List(context.TODO(), metav1.ListOptions{})
fmt.Println("üîç Pods count:", len(pods.Items))
{% elif "database" in prompt.lower() %}
go
// Database connection with sqlx
db, err := sqlx.Connect("postgres", "user=foo dbname=bar sslmode=disable")
if err != nil {
    log.Fatalln(err)
}
fmt.Println("üíæ Connected to DB successfully")
{% endif %}

---

# 5. Fire Elements That Engineers Love üî•

go
// validateAndFix ensures syntax + formatting is correct
func validateAndFix() {
    run("go", "fmt", "./...")
    run("go", "vet", "./...")
}

// smartRecovery shows contextual fixes
func smartRecovery(err error) {
    if strings.Contains(err.Error(), "no required module") {
        warn("Missing module detected ‚Äì running go mod tidy")
        run("go", "mod", "tidy")
    } else {
        warn("Unexpected error: " + err.Error())
    }
}

// parallelExecution runs tasks concurrently
func parallelExecution(tasks []func()) {
    var wg sync.WaitGroup
    for _, task := range tasks {
        wg.Add(1)
        go func(t func()) {
            defer wg.Done()
            t()
        }(task)
    }
    wg.Wait()
}

// benchmark wrapper
func benchmark(name string, fn func()) {
    start := time.Now()
    fn()
    fmt.Printf("‚è±Ô∏è %s completed in %s\n", name, time.Since(start))
}

---

# 6. The "Damn, This is Smart" Moment üí°

jinja2
{% if "sensitive" in prompt.lower() %}
go
// backupBeforeChanges creates tarball backup before destructive ops
func backupBeforeChanges() {
    out := fmt.Sprintf("/tmp/backup_%d.tar.gz", time.Now().Unix())
    run("tar", "-czf", out, ".")
    success("üíæ Backup created: " + out)
}
{% endif %}

---

# 7. Professional Polish üé©

go
var (
    Version   = "1.0.0"
    Author    = "Generated by AI Copilot"
    Requires  = "go1.18+"
)

func showInfo() {
    fmt.Println("App Version:", Version)
    fmt.Println("Author:", Author)
    fmt.Println("Go Version:", runtime.Version())
    fmt.Println("Generated:", time.Now().Format(time.RFC3339))
}

---

# 8. Template Enhancement for Maximum Fire üöÄ

jinja2
# üî• FIRE MODE: Advanced Patterns for {{ prompt }}
{% if "api" in prompt.lower() %}
# Include production API scaffolding
{% include 'patterns/go_api.jinja2' %}
{% elif "worker" in prompt.lower() %}
# Background worker with concurrency-safe patterns
{% include 'patterns/go_worker.jinja2' %}
{% elif "monitoring" in prompt.lower() %}
# Observability stack with Prometheus metrics
{% include 'patterns/go_monitoring.jinja2' %}
{% endif %}

# üí° Pro Tips Generated for This Script:
{% for tip in prompt|generate_pro_tips %}
# {{ tip }}
{% endfor %}

---

# Bottom Line for Engineers
Your template should generate Go code that makes engineers think:

- "This just bootstraps my project instantly" (instant gratification)  
- "It knows whether I‚Äôm building API, CLI, or infra" (smart defaults)  
- "This is idiomatic, concurrency-safe Go" (production-ready)  
- "It feels like a senior Go engineer set this up for me" (tribal knowledge baked in)  
- "It even auto-formats, recovers, benchmarks, and scaffolds APIs" (wow factor 10/10)  